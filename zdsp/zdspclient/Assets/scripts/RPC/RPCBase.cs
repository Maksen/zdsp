//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#define PROFILE_RPC
using System;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using ExitGames.Client.Photon;
//using ExitGames.Client.Photon.Lite;
using Zealot.Common.RPC;
using Zealot.Common.Actions;

public class RPCBase : MarshalByRefObject
{
    struct ClientStubInfo
    {
        public readonly byte MethodID;
        public readonly bool SuspendRPC;

        public ClientStubInfo(byte id, bool suspend)
        {
            MethodID = id;
            SuspendRPC = suspend;
        }
    }

    struct RPCMethodInfo
    {
        public readonly string MethodName;
        public bool UnsuspendRPC;

        public RPCMethodInfo(string name, bool unsuspend = false)
        {
            MethodName = name;
            UnsuspendRPC = unsuspend;
        }
    }


    byte opcode;
	Dictionary<string, object> schemaregistry;
	public const byte INIT_PCODE = 0;
	private Dictionary<byte, object> mPackedDic;
    private Dictionary<string, ClientStubInfo> callerNameToStubInfo;
    private Dictionary<byte, RPCMethodInfo> calleeIDToMethodInfo;
    private bool mbUsePackRPC = false;
	private byte mPackIdx = 0;
	Type mTmainContext;

    //Profiling Counters
    protected int bytesReceivedThisFrame;
    protected int bytesSentThisFrame;
    public int BytesReceivedThisFrame { get { return bytesReceivedThisFrame; } }
    public int BytesSentThisFrame { get { return bytesSentThisFrame; } }

    private byte GetMethodID(string methodName)
    {
        return callerNameToStubInfo[methodName].MethodID;
    }

    public RPCBase (Type subclass, byte subopcode)
	{
		schemaregistry = new Dictionary<string, object> ();
        callerNameToStubInfo = new Dictionary<string, ClientStubInfo>();
        calleeIDToMethodInfo = new Dictionary<byte, RPCMethodInfo>();

        MethodInfo[] methods = subclass.GetMethods ();
		foreach (MethodInfo m in methods)
        {
            Object [] atts = m.GetCustomAttributes(typeof(RPCMethodAttribute), true);
            RPCMethodAttribute att = null;
            if (atts.Length > 0)
                att = (RPCMethodAttribute)atts[0];

            if (att != null) //is RPC caller method
            {
                byte pcode = INIT_PCODE;
                Dictionary<byte, object> mdb = new Dictionary<byte, object>();
                mdb.Add(pcode, m.Name);
                pcode++;
                ParameterInfo[] parameterlist = m.GetParameters();
                foreach (ParameterInfo p in parameterlist)
                {
                    mdb.Add(pcode, null);
                    pcode++;
                }
                schemaregistry.Add(m.Name, mdb);
                var stubinfo = new ClientStubInfo(att.MethodID, att.SuspendRPC);
                callerNameToStubInfo.Add(m.Name, stubinfo);
            }
		}

		opcode = subopcode;
	}

	public void SetMainContext(Type t, RPCCategory cat)
	{
		mTmainContext = t;
        calleeIDToMethodInfo.Clear();

        //Search for callee/receiving methods that are used for RPC
        MethodInfo[] methods = mTmainContext.GetMethods();
        foreach (MethodInfo m in methods)
        {
            Object[] atts = m.GetCustomAttributes(typeof(RPCMethodAttribute), true);
            RPCMethodAttribute att = null;
            if (atts.Length > 0)
                att = (RPCMethodAttribute)atts[0];

            if (att != null && att.Category == cat) //is RPC callee method
            {
                var minfo = new RPCMethodInfo(m.Name);

                var unsuspendatt = m.GetCustomAttributes(typeof(RPCUnsuspendAttribute), true);
                if (unsuspendatt.Length > 0)
                {
                    minfo.UnsuspendRPC = true;
                }
                calleeIDToMethodInfo.Add(att.MethodID, minfo);
            }
        }
    }

	public Dictionary<byte, object> GetMethod(string name)
	{
		return (Dictionary<byte, object>)schemaregistry [name];
	}

    // client side only single command. no need to pack into one 
	public void ProxyMethod(string methodname, params object[] args)
	{
        if (RPCFactory.Suspended)
            return;

		if (methodname == "SendAction") {
			Dictionary<byte, object> dic = args[0] as Dictionary<byte, object>;
			SendCommand (dic);
		} else {
			byte pcode = INIT_PCODE;
			Dictionary<byte, object> dic = new Dictionary<byte, object> ();
			dic.Add (pcode++, 0);

            var stubinfo = callerNameToStubInfo[methodname];
            byte methodid = stubinfo.MethodID;
            dic.Add (pcode++, methodid);
		
			foreach (object param in args)
            {                
                //Handle complicated Types here:                
                Type paramType = param == null ? null : param.GetType();
                if (paramType == typeof(RPCPosition))
                {
                    RPCPosition rpcpos = (RPCPosition)param;
                    dic.Add(pcode++, rpcpos.X);
                    dic.Add(pcode++, rpcpos.Y);
                    dic.Add(pcode++, rpcpos.Z);
                }
                else if (paramType == typeof(RPCDirection))
                {
                    dic.Add(pcode++, ((RPCDirection)param).YawEncodedPhoton);
                }
                else
                    dic.Add(pcode++, param);                
            }
			SendCommand (dic);

            if (stubinfo.SuspendRPC)
                RPCFactory.SuspendRPC();
        }
	}

	public byte GetOpCode()
	{
		return opcode;
	}

	// to override
	public void SendCommand(Dictionary<byte, object> dic)
    {
#if PROFILE_RPC
        bytesSentThisFrame += ComputeDataSize(dic);
#endif
        PhotonNetwork.networkingPeer.OpCustom (GetOpCode(), dic, true);
	}

	public object OnProxyMethodController(Dictionary<byte, object> param, ref byte opcd, object target)
	{
        byte methodid = (byte)param[opcd++];
        var minfo = calleeIDToMethodInfo[methodid];
        string methodname = minfo.MethodName;
        MethodInfo m = mTmainContext.GetMethod(methodname);
		ParameterInfo[] pInfos = m.GetParameters();
		object[] args = new object[pInfos.Length];
		int i = 0;
		foreach (ParameterInfo p in pInfos)
		{            
            //Handle complicated types here:            
            Type paramType = p.ParameterType;
            if (paramType == typeof(RPCPosition))
            {
                RPCPosition rpcpos = new RPCPosition((short)param[opcd++], (short)param[opcd++], (short)param[opcd++]);
                args[i] = rpcpos;
            }
            else if (paramType == typeof(RPCDirection))
            {
                args[i] = new RPCDirection((short)param[opcd++]);
            }
            else
                args[i] = param[opcd++];
            i++;
		}

        if (minfo.UnsuspendRPC)
            RPCFactory.UnSuspendRPC();

		object retval = m.Invoke(target, args);        
		return retval;
	}

	public object OnProxyMethodControllerList(Dictionary<byte, object> param, object target)
	{
		byte opcd = INIT_PCODE + 1;				
		while(param.ContainsKey(opcd))
		{
			OnProxyMethodController(param, ref opcd, target);
		}
		return null;  
	}

	public void BeginRPC()
	{
		mbUsePackRPC = true;
		mPackedDic = new Dictionary<byte, object>();
		mPackedDic.Add(mPackIdx++, 1);      // multi commands
	}
	
	public void EndRPC()
	{
		mPackIdx = 0;
		mbUsePackRPC = false;
	}
	
	public void OnCommand(object obj, EventData eventdata)
	{
#if PROFILE_RPC
        bytesReceivedThisFrame += ComputeDataSize(eventdata.Parameters);
#endif

        byte pcode = INIT_PCODE;
		int cmdMode = (int)eventdata.Parameters[pcode++];
		if (cmdMode == 0)
		{
			object retval = OnProxyMethodController(eventdata.Parameters, ref pcode, obj);
		}
		else
		{
			OnProxyMethodControllerList(eventdata.Parameters, obj);                
		}
	}


    #region Profiling

    protected int ComputeDataSize(Dictionary<byte, object> data)
    {
        int totalBytes = 0;
        foreach (KeyValuePair<byte, object> entry in data)
        {
            object value = entry.Value;
            if (value != null)
            {
                if (value is string)
                    totalBytes += 1 + System.Text.Encoding.ASCII.GetByteCount((string)value); //+1 for extra byte for key of dictionary
                else if (value is ACTIONTYPE)
                {
                    totalBytes += 1 + sizeof(ACTIONTYPE);
                }
                else if (value.GetType().IsArray == true)
                {
                    Type t = value.GetType();
                    if(t.Name == "Int32[]")
                    {
                        int[] valuearr = (int[])entry.Value;
                        foreach (var temp in valuearr)
                        {
                            totalBytes += 1 + System.Runtime.InteropServices.Marshal.SizeOf(temp);
                        }
                    }
                    else if(t.Name == "String[]")
                    {
                        string[] valuearr = (string[])entry.Value;
                        foreach (var temp in valuearr)
                        {
                            totalBytes += 1 + System.Text.Encoding.ASCII.GetByteCount(temp); //+1 for extra byte for key of dictionary
                        }
                    }
                    
                   
                }
                else
                    totalBytes += 1 + System.Runtime.InteropServices.Marshal.SizeOf(value);
            }
        }
        return totalBytes;        
    }

    public void ResetProfilingCounters()
    {
        bytesReceivedThisFrame = 0;
        bytesSentThisFrame = 0;
    }
    #endregion
}


